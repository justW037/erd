/**
 * Export Utilities
 * 
 * Export diagram as:
 * - SVG (vector)
 * - PNG (raster)
 * - SQL DDL (database schema)
 */


import type {
  DatabaseSchema,
  Table,
  Column,
  Relation,
} from '../core/ir/types'
export function exportToSVG(svgElement: SVGSVGElement): string {
  const clone = svgElement.cloneNode(true) as SVGSVGElement
  
  // Remove UI elements (zoom indicator, etc.)
  const textsToRemove = clone.querySelectorAll('text[x="10"][y="20"]')
  textsToRemove.forEach((el) => el.remove())

  // Set proper dimensions
  const bounds = svgElement.getBBox()
  clone.setAttribute('viewBox', `${bounds.x - 20} ${bounds.y - 20} ${bounds.width + 40} ${bounds.height + 40}`)
  clone.setAttribute('width', String(bounds.width + 40))
  clone.setAttribute('height', String(bounds.height + 40))

  // Serialize
  // eslint-disable-next-line no-undef
  const serializer = new XMLSerializer()
  let svgString = serializer.serializeToString(clone)

  // Add XML declaration
  svgString = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgString

  return svgString
}

export function downloadSVG(svgElement: SVGSVGElement, filename = 'diagram.svg'): void {
  const svgString = exportToSVG(svgElement)
  const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' })
  downloadBlob(blob, filename)
}

// ─────────────────────────────────────────────────────────────
// PNG Export
// ─────────────────────────────────────────────────────────────

export async function exportToPNG(
  svgElement: SVGSVGElement,
  scale = 2
): Promise<Blob> {
  const svgString = exportToSVG(svgElement)
  const bounds = svgElement.getBBox()
  const width = (bounds.width + 40) * scale
  const height = (bounds.height + 40) * scale

  // Create canvas
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  const ctx = canvas.getContext('2d')!

  // Fill white background
  ctx.fillStyle = '#ffffff'
  ctx.fillRect(0, 0, width, height)

  // Load SVG as image
  const img = new Image()
  const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' })
  const url = URL.createObjectURL(svgBlob)

  return new Promise((resolve, reject) => {
    img.onload = () => {
      ctx.drawImage(img, 0, 0, width, height)
      URL.revokeObjectURL(url)
      canvas.toBlob((blob) => {
        if (blob) resolve(blob)
        else reject(new Error('Failed to create PNG blob'))
      }, 'image/png')
    }
    img.onerror = reject
    img.src = url
  })
}

export async function downloadPNG(
  svgElement: SVGSVGElement,
  filename = 'diagram.png',
  scale = 2
): Promise<void> {
  const blob = await exportToPNG(svgElement, scale)
  downloadBlob(blob, filename)
}

// ─────────────────────────────────────────────────────────────
// SQL DDL Export
// ─────────────────────────────────────────────────────────────

export type SQLDialect = 'postgresql' | 'mysql' | 'sqlite'

export function exportToSQL(schema: DatabaseSchema, dialect: SQLDialect = 'postgresql'): string {
  const lines: string[] = []
  const q = dialect === 'mysql' ? '`' : '"'

  // Add header comment
  lines.push(`-- Generated by ERD Tool`)
  lines.push(`-- Dialect: ${dialect}`)
  lines.push(`-- Date: ${new Date().toISOString()}`)
  lines.push('')

  // Export enums (PostgreSQL only)
  if (dialect === 'postgresql') {
    for (const enumDef of schema.enums) {
      const values = enumDef.values.map((v) => `'${v.name}'`).join(', ')
      lines.push(`CREATE TYPE ${q}${enumDef.name}${q} AS ENUM (${values});`)
      lines.push('')
    }
  }

  // Export tables
  for (const table of schema.tables) {
    lines.push(generateCreateTable(table, schema.relations, dialect, q))
    lines.push('')
  }

  // Export foreign key constraints (after all tables created)
  for (const rel of schema.relations) {
    lines.push(generateForeignKey(rel, dialect, q))
  }

  return lines.join('\n')
}

function generateCreateTable(
  table: Table,
  relations: Relation[],
  dialect: SQLDialect,
  q: string
): string {
  const lines: string[] = []
  lines.push(`CREATE TABLE ${q}${table.name}${q} (`)

  const columnDefs: string[] = []
  const primaryKeys: string[] = []

  for (const col of table.columns) {
    let def = `  ${q}${col.name}${q} ${mapColumnTypeToSQL(col, dialect)}`

    if (col.settings.notNull) def += ' NOT NULL'
    if (col.settings.unique) def += ' UNIQUE'
    if (col.settings.autoIncrement) {
      if (dialect === 'postgresql') def = def.replace(/int/i, 'SERIAL')
      else if (dialect === 'mysql') def += ' AUTO_INCREMENT'
      else if (dialect === 'sqlite') def += ' AUTOINCREMENT'
    }
    if (col.settings.default !== undefined && col.settings.default !== null) {
      const val = typeof col.settings.default === 'string'
        ? `'${col.settings.default}'`
        : col.settings.default
      def += ` DEFAULT ${val}`
    }

    columnDefs.push(def)

    if (col.settings.primaryKey) {
      primaryKeys.push(col.name)
    }
  }

  lines.push(columnDefs.join(',\n'))

  if (primaryKeys.length > 0) {
    const pkCols = primaryKeys.map((c) => `${q}${c}${q}`).join(', ')
    lines.push(`,  PRIMARY KEY (${pkCols})`)
  }

  lines.push(');')

  // Add table comment if exists
  if (table.note && dialect === 'postgresql') {
    lines.push(`COMMENT ON TABLE ${q}${table.name}${q} IS '${table.note.replace(/'/g, "''")}';`)
  }

  return lines.join('\n')
}

function mapColumnTypeToSQL(col: Column, dialect: SQLDialect): string {
  const t = col.type
  const len = col.settings.length
  const prec = col.settings.precision
  const scale = col.settings.scale

  switch (t) {
    case 'int':
      return dialect === 'postgresql' ? 'INTEGER' : 'INT'
    case 'bigint':
      return 'BIGINT'
    case 'smallint':
      return 'SMALLINT'
    case 'float':
      return dialect === 'postgresql' ? 'REAL' : 'FLOAT'
    case 'double':
      return dialect === 'postgresql' ? 'DOUBLE PRECISION' : 'DOUBLE'
    case 'decimal':
      if (prec && scale) return `DECIMAL(${prec}, ${scale})`
      if (prec) return `DECIMAL(${prec})`
      return 'DECIMAL'
    case 'varchar':
      return len ? `VARCHAR(${len})` : 'VARCHAR(255)'
    case 'char':
      return len ? `CHAR(${len})` : 'CHAR(1)'
    case 'text':
      return 'TEXT'
    case 'boolean':
      return dialect === 'mysql' ? 'TINYINT(1)' : 'BOOLEAN'
    case 'date':
      return 'DATE'
    case 'datetime':
      return dialect === 'postgresql' ? 'TIMESTAMP' : 'DATETIME'
    case 'timestamp':
      return 'TIMESTAMP'
    case 'time':
      return 'TIME'
    case 'uuid':
      return dialect === 'postgresql' ? 'UUID' : 'CHAR(36)'
    case 'json':
      return dialect === 'postgresql' ? 'JSONB' : 'JSON'
    case 'blob':
      return dialect === 'postgresql' ? 'BYTEA' : 'BLOB'
    case 'enum':
      // Use raw type name for PostgreSQL enum, or VARCHAR for others
      if (dialect === 'postgresql' && col.rawType) return `"${col.rawType}"`
      return 'VARCHAR(50)'
    default:
      return col.rawType ?? 'TEXT'
  }
}

function generateForeignKey(rel: Relation, dialect: SQLDialect, q: string): string {
  const constraintName = `fk_${rel.from.table}_${rel.from.column}`
  return `ALTER TABLE ${q}${rel.from.table}${q} ADD CONSTRAINT ${q}${constraintName}${q} FOREIGN KEY (${q}${rel.from.column}${q}) REFERENCES ${q}${rel.to.table}${q}(${q}${rel.to.column}${q});`
}

export function downloadSQL(
  schema: DatabaseSchema,
  filename = 'schema.sql',
  dialect: SQLDialect = 'postgresql'
): void {
  const sql = exportToSQL(schema, dialect)
  const blob = new Blob([sql], { type: 'text/sql;charset=utf-8' })
  downloadBlob(blob, filename)
}

// ─────────────────────────────────────────────────────────────
// Helper
// ─────────────────────────────────────────────────────────────

function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}
